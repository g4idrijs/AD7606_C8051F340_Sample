C51 COMPILER V9.01   USB_MAIN                                                              05/07/2015 17:10:08 PAGE 1   


C51 COMPILER V9.01, COMPILATION OF MODULE USB_MAIN
OBJECT MODULE PLACED IN USB_MAIN.OBJ
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE USB_MAIN.c BROWSE DEBUG OBJECTEXTEND

line level    source

   1          //#include "compiler_defs.h"
   2          #include <c8051f340.h>
   3          #include <stddef.h>
   4          #include "USB_API.h"
   5          #include "C8051F340_AD7606.h"
   6          #include "stdio.h"
   7                                                                                                                                                                                  
   8          sbit Led = P2^3;
   9          
  10          
  11          
  12          
  13          // Constants Definitions
  14          #define  NUM_STG_PAGES  20 // Total number of flash pages to be used for file storage
  15          #define  MAX_BLOCK_SIZE_READ     64 // Use the maximum read block size of 64 bytes
  16          #define  MAX_BLOCK_SIZE_WRITE    4096   // Use the maximum write block size of 4096 bytes
  17          #define  FLASH_PAGE_SIZE         512    //  Size of each flash page
  18          #define  BLOCKS_PR_PAGE  FLASH_PAGE_SIZE/MAX_BLOCK_SIZE_READ  // 512/64 = 8
  19          #define  MAX_NUM_BYTES   FLASH_PAGE_SIZE*NUM_STG_PAGES
  20          #define  MAX_NUM_BLOCKS  BLOCKS_PR_PAGE*NUM_STG_PAGES
  21          // Message Types
  22          #define  READ_MSG          0x00  // Message types for communication with host
  23          #define  WRITE_MSG         0x01
  24          #define  SIZE_MSG          0x02
  25          #define  DELAYED_READ_MSG  0x05
  26          // Machine States
  27          #define  ST_WAIT_DEV    0x01  // Wait for application to open a device instance
  28          #define  ST_IDLE_DEV    0x02  // Device is open, wait for Setup Message from host
  29          #define  ST_RX_SETUP    0x04  // Received Setup Message, decode and wait for data
  30          #define  ST_RX_FILE     0x08  // Receive file data from host
  31          #define  ST_TX_FILE     0x10  // Transmit file data to host
  32          #define  ST_TX_ACK      0x20  // Transmit ACK 0xFF back to host after every 8 packets
  33          #define  ST_ERROR       0x80  // Error state
  34          typedef struct {        // Structure definition of a block of data
  35             unsigned char  Piece[MAX_BLOCK_SIZE_READ];
  36          }  BLOCK;
  37          typedef struct {        // Structure definition of a flash memory page
  38             U8  FlashPage[FLASH_PAGE_SIZE];
  39          }  PAGE;
  40          
  41          SEGMENT_VARIABLE(TempStorage[BLOCKS_PR_PAGE], BLOCK, SEG_XDATA); //Temporary storage of between flash writ
             -es
  42          
  43          SEGMENT_VARIABLE_SEGMENT_POINTER(PageIndices[20], U8, SEG_CODE, SEG_DATA);
  44          
  45          SEGMENT_VARIABLE(BytesToRead, U16, SEG_DATA); // Total number of bytes to read from host
  46          SEGMENT_VARIABLE(WriteStageLength, U16, SEG_DATA); //  Current write transfer stage length
  47          SEGMENT_VARIABLE(ReadStageLength, U16, SEG_DATA);  //  Current read transfer stage length
  48          SEGMENT_VARIABLE(Buffer[3], U8, SEG_DATA);   // Buffer for Setup messages
  49          SEGMENT_VARIABLE(NumBytes, U16, SEG_DATA);   // Number of Blocks for this transfer
  50          SEGMENT_VARIABLE(NumBlocks, U8, SEG_DATA);
  51          SEGMENT_VARIABLE(BytesRead, U16, SEG_DATA);  // Number of Bytes Read
  52          SEGMENT_VARIABLE(M_State, U8, SEG_DATA);     // Current Machine State
  53          SEGMENT_VARIABLE(BytesWrote, U16, SEG_DATA); // Number of Bytes Written
  54          SEGMENT_VARIABLE(BlockIndex, U8, SEG_DATA);  // Index of Current Block in Page
C51 COMPILER V9.01   USB_MAIN                                                              05/07/2015 17:10:08 PAGE 2   

  55          SEGMENT_VARIABLE(PageIndex, U8, SEG_DATA);   // Index of Current Page in File
  56          SEGMENT_VARIABLE(BlocksWrote, U8, SEG_DATA); // Total Number of Blocks Written
  57          #if defined __C51__
  58             SEGMENT_VARIABLE(ReadIndex, U8*, SEG_DATA);
  59          #elif defined SDCC
                 SEGMENT_VARIABLE_SEGMENT_POINTER(ReadIndex, U8, SEG_CODE, SEG_DATA);
              #endif
  62          SEGMENT_VARIABLE(BytesToWrite, U16, SEG_DATA);
  63          
  64          LOCATED_VARIABLE_NO_INIT(LengthFile[3], U8, SEG_CODE, 0x2000);
  65             // {Length(Low Byte), Length(High Byte), Number of Blocks}
  66          
  67          
  68          
  69          U8 In_Packet[2]; // Last packet received from host
  70          extern U8 Out_Packet[16];
  71          //U8 Ax[32] ={1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32};
  72          U8 i;
  73          
  74          /*** [BEGIN] USB Descriptor Information [BEGIN] ***/
  75          code const UINT USB_VID = 0x10C4;                                                               
  76          code const UINT USB_PID = 0xEA61;
  77          code const BYTE USB_MfrStr[] = {0x1A,0x03,'S',0,'i',0,'l',0,'i',0,'c',0,'o',0,'n',0,' ',0,'L',0,'a',0,'b',
             -0,'s',0};
  78          code const BYTE USB_ProductStr[] = {0x10,0x03,'U',0,'S',0,'B',0,' ',0,'A',0,'P',0,'I',0};
  79          code const BYTE USB_SerialStr[] = {0x0A,0x03,'i',0,'d',0,'r',0,'i',0};
  80          code const BYTE USB_MaxPower = 15;
  81          code const BYTE USB_PwAttributes = 0x80; // Bus-powered, remote wakeup not supported
  82          code const UINT USB_bcdDevice = 0x0100;
  83          /*** [ END ] USB Descriptor Information [ END ] ***/
  84          
  85          void Oscillator_Init();
  86          void Port_Init(void);
  87          void Suspend_Device(void);
  88          
  89          void main(void)
  90          {
  91   1         PCA0MD &= ~0x40;
  92   1         
  93   1         USB_Clock_Start();
  94   1         USB_Init(USB_VID,USB_PID,USB_MfrStr,USB_ProductStr,USB_SerialStr,USB_MaxPower,USB_PwAttributes,USB_bcdD
             -evice);
  95   1         USB_Int_Enable();
  96   1      
  97   1         Oscillator_Init();
  98   1         Port_Init();
  99   1      
 100   1         AD7606_Init();
 101   1         
 102   1         while (1)
 103   1         {
 104   2            if (In_Packet[0] == 1) Led = 1;
 105   2            else Led = 0;
 106   2                AD7606_Read();
 107   2                Block_Write(Out_Packet, 16);
 108   2                //Block_Write(Ax, 32);      
 109   2         }
 110   1      }
 111          
 112          void Port_Init(void)
 113          {
 114   1              P0MDIN |= 0x40;// Port 0 pin 3 set as BUSY input
C51 COMPILER V9.01   USB_MAIN                                                              05/07/2015 17:10:08 PAGE 3   

 115   1              P0MDOUT = 0xcf; //0x10 : Set TX pin to push-pull        
 116   1      
 117   1              P1MDIN |= 0xff; 
 118   1              P1MDOUT = 0x00;
 119   1              P1 |= 0xff;//Set port latches to '1'
 120   1      
 121   1              P2MDOUT = 0xf8;
 122   1              //P2 |= 0x00;
 123   1      
 124   1              P3MDIN |= 0xff; 
 125   1              P3MDOUT = 0x00;
 126   1              P3 |= 0xff;//Set port latches to '1'              
 127   1      
 128   1              XBR0 = 0x01;// Enable UART0
 129   1              XBR1 = 0x40;// Enable crossbar and weak pull-ups
 130   1      }
 131          
 132          void Oscillator_Init()
 133          {                                                               
 134   1          CLKSEL = 0x00; // Select the internal osc. as the SYSCLK source
 135   1          OSCICN = 0x83; // configure internal oscillator for 12MHz / 1
 136   1              RSTSRC = 0x04; // enable missing clock detector
 137   1      }
 138          
 139          void Suspend_Device(void)
 140          {
 141   1         // Disable peripherals before calling USB_Suspend()
 142   1         P0MDIN = 0x00;                       // Port 0 configured as analog input
 143   1         P1MDIN = 0x00;                       // Port 1 configured as analog input
 144   1         P2MDIN = 0x00;                       // Port 2 configured as analog input
 145   1         P3MDIN = 0x00;                       // Port 3 configured as analog input
 146   1      
 147   1         USB_Suspend();                       // Put the device in suspend state
 148   1      
 149   1         // Once execution returns from USB_Suspend(), device leaves suspend state.Reenable peripherals
 150   1         P0MDIN = 0xFF;
 151   1         P1MDIN = 0x7F;                       // Port 1 pin 7 set as analog input
 152   1         P2MDIN = 0xFF;
 153   1         P3MDIN = 0x01;
 154   1      }
 155          
 156          // Example ISR for USB_API
 157          void  USB_API_TEST_ISR(void) interrupt 17
 158          {
 159   1         BYTE INTVAL = Get_Interrupt_Source();
 160   1      
 161   1         if (INTVAL & RX_COMPLETE)
 162   1         {
 163   2            Block_Read(In_Packet, 2);
 164   2         }
 165   1      
 166   1         if (INTVAL & DEV_SUSPEND)
 167   1         {
 168   2              Suspend_Device();
 169   2         }
 170   1      
 171   1         if (INTVAL & DEV_CONFIGURED)
 172   1         {
 173   2                      Oscillator_Init();
 174   2                      Port_Init();
 175   2         }
 176   1      }
C51 COMPILER V9.01   USB_MAIN                                                              05/07/2015 17:10:08 PAGE 4   



MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    301    ----
   CONSTANT SIZE    =     60    ----
   XDATA SIZE       =    512    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     68       1
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
