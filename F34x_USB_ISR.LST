C51 COMPILER V9.01   F34X_USB_ISR                                                          05/12/2015 22:23:48 PAGE 1   


C51 COMPILER V9.01, COMPILATION OF MODULE F34X_USB_ISR
OBJECT MODULE PLACED IN F34x_USB_ISR.OBJ
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE F34x_USB_ISR.c BROWSE DEBUG OBJECTEXTEND

line level    source

   1          //-----------------------------------------------------------------------------
   2          // F34x_USB_ISR.c
   3          //-----------------------------------------------------------------------------
   4          // Copyright 2005 Silicon Laboratories, Inc.
   5          // http://www.silabs.com
   6          //
   7          // Program Description:
   8          //
   9          // Source file for USB firmware. Includes top level ISR with Setup,
  10          // and Endpoint data handlers.  Also includes routine for USB suspend,
  11          // reset, and procedural stall.
  12          //
  13          //
  14          // How To Test:    See Readme.txt
  15          //
  16          //
  17          // FID:            34X000018
  18          // Target:         C8051F34x
  19          // Tool chain:     Keil C51 7.50 / Keil EVAL C51
  20          //                 Silicon Laboratories IDE version 2.6
  21          // Command Line:   See Readme.txt
  22          // Project Name:   F34x_USB_Interrupt
  23          //
  24          //
  25          // Release 1.0
  26          //    -Initial Revision (GP)
  27          //    -22 NOV 2005
  28          //    -Ported from 'F320_USB_Bulk
  29          //
  30          
  31          //-----------------------------------------------------------------------------
  32          // Includes
  33          //-----------------------------------------------------------------------------
  34          
  35          #include "c8051F340.h"
  36          #include "F34x_USB_Register.h"
  37          #include "USB_MAIN.h"
  38          #include "F34x_USB_Descriptor.h"
  39          
  40          //-----------------------------------------------------------------------------
  41          // Global Externs
  42          //-----------------------------------------------------------------------------
  43          
  44          extern idata BYTE OUT_PACKET[];
  45          extern idata BYTE IN_PACKET[];
  46          
  47          //-----------------------------------------------------------------------------
  48          // Global Variables
  49          //-----------------------------------------------------------------------------
  50          
  51          BYTE USB_State;                        // Holds the current USB State
  52                                                 // def. in F32x_USB_Main.h
  53          
  54          setup_buffer Setup;                    // Buffer for current device request
  55          
C51 COMPILER V9.01   F34X_USB_ISR                                                          05/12/2015 22:23:48 PAGE 2   

  56          unsigned int DataSize;                 // Size of data to return
  57          unsigned int DataSent;                 // Amount of data sent so far
  58          BYTE* DataPtr;                         // Pointer to data to return
  59          
  60          // Holds the status for each endpoint
  61          BYTE Ep_Status[3] = {EP_IDLE, EP_IDLE, EP_IDLE};
  62          
  63          
  64          //-----------------------------------------------------------------------------
  65          // Interrupt Service Routines
  66          //-----------------------------------------------------------------------------
  67          
  68          //-----------------------------------------------------------------------------
  69          // USB0_ISR
  70          //-----------------------------------------------------------------------------
  71          //
  72          // Called after any USB type interrupt, this handler determines which type
  73          // of interrupt occurred, and calls the specific routine to handle it.
  74          //
  75          //-----------------------------------------------------------------------------
  76          void USB0_ISR(void) interrupt 8        // Top-level USB ISR
  77          {
  78   1         BYTE bCommon, bIn, bOut;
  79   1         POLL_READ_BYTE(CMINT, bCommon);     // Read all interrupt registers
  80   1         POLL_READ_BYTE(IN1INT, bIn);        // this read also clears the register
  81   1         POLL_READ_BYTE(OUT1INT, bOut);
  82   1         {
  83   2            if (bCommon & rbRSUINT)          // Handle Resume interrupt
  84   2            {
  85   3               Usb_Resume();
  86   3            }
  87   2            if (bCommon & rbRSTINT)          // Handle Reset interrupt
  88   2            {
  89   3               Usb_Reset();
  90   3            }
  91   2            if (bIn & rbEP0)                 // Handle Setup packet received
  92   2            {                                // or packet transmitted if Endpoint 0
  93   3               Handle_Setup();               // is transmit mode
  94   3            }
  95   2            if (bIn & rbIN1)                 // Handle In Packet sent, put new data
  96   2            {                                // on endpoint 1 fifo
  97   3               Handle_In1();
  98   3            }
  99   2            if (bOut & rbOUT2)               // Handle Out packet received, take data
 100   2            {                                // off endpoint 2 fifo
 101   3               Handle_Out2();
 102   3            }
 103   2            if (bCommon & rbSUSINT)          // Handle Suspend interrupt
 104   2            {
 105   3               Usb_Suspend();
 106   3            }
 107   2         }
 108   1      }
 109          
 110          //-----------------------------------------------------------------------------
 111          // Support Routines for ISR
 112          //-----------------------------------------------------------------------------
 113          
 114          //-----------------------------------------------------------------------------
 115          // Usb_Reset
 116          //-----------------------------------------------------------------------------
 117          //
C51 COMPILER V9.01   F34X_USB_ISR                                                          05/12/2015 22:23:48 PAGE 3   

 118          // Return Value : None
 119          // Parameters   : None
 120          //
 121          // - Set state to default
 122          // - Clear Usb Inhibit bit
 123          //
 124          //-----------------------------------------------------------------------------
 125          
 126          void Usb_Reset(void)
 127          {
 128   1         USB_State = DEV_DEFAULT;            // Set device state to default
 129   1      
 130   1         POLL_WRITE_BYTE(POWER, 0x01);       // Clear usb inhibit bit to enable USB
 131   1                                             // suspend detection
 132   1      
 133   1         Ep_Status[0] = EP_IDLE;             // Set default Endpoint Status
 134   1         Ep_Status[1] = EP_HALT;
 135   1         Ep_Status[2] = EP_HALT;
 136   1      }
 137          
 138          //-----------------------------------------------------------------------------
 139          // Handle_Setup
 140          //-----------------------------------------------------------------------------
 141          //
 142          // Return Value : None
 143          // Parameters   : None
 144          //
 145          // - Decode Incoming Setup requests
 146          // - Load data packets on fifo while in transmit mode
 147          //
 148          //-----------------------------------------------------------------------------
 149          
 150          void Handle_Setup(void)
 151          {
 152   1         BYTE ControlReg,TempReg;            // Temporary storage for EP control
 153   1                                             // register
 154   1      
 155   1         POLL_WRITE_BYTE(INDEX, 0);          // Set Index to Endpoint Zero
 156   1         POLL_READ_BYTE(E0CSR, ControlReg);  // Read control register
 157   1      
 158   1         if (Ep_Status[0] == EP_ADDRESS)     // Handle Status Phase of Set Address
 159   1                                             // command
 160   1         {
 161   2            POLL_WRITE_BYTE(FADDR, Setup.wValue.c[LSB]);
 162   2            Ep_Status[0] = EP_IDLE;
 163   2         }
 164   1      
 165   1         if (ControlReg & rbSTSTL)           // If last packet was a sent stall, reset
 166   1         {                                   // STSTL bit and return EP0 to idle state
 167   2            POLL_WRITE_BYTE(E0CSR, 0);
 168   2            Ep_Status[0] = EP_IDLE;
 169   2            return;
 170   2         }
 171   1      
 172   1         if (ControlReg & rbSUEND)           // If last setup transaction was ended
 173   1         {                                   // prematurely then set
 174   2            POLL_WRITE_BYTE(E0CSR, rbDATAEND);
 175   2            POLL_WRITE_BYTE(E0CSR, rbSSUEND); // Serviced Setup End bit and return EP0
 176   2            Ep_Status[0] = EP_IDLE;          // to idle state
 177   2         }
 178   1      
 179   1         if (Ep_Status[0] == EP_IDLE)        // If Endpoint 0 is in idle mode
C51 COMPILER V9.01   F34X_USB_ISR                                                          05/12/2015 22:23:48 PAGE 4   

 180   1         {
 181   2            if (ControlReg & rbOPRDY)        // Make sure that EP 0 has an Out Packet ready from host
 182   2            {                                // although if EP0 is idle, this should always be the case
 183   3               Fifo_Read(FIFO_EP0, 8, (BYTE *)&Setup);
 184   3                                              // Get Setup Packet off of Fifo, it is currently Big-Endian
 185   3      
 186   3                                             // Compiler Specific - these next three statements swap the
 187   3                                             // bytes of the setup packet words to Big Endian so they
 188   3                                             // can be compared to other 16-bit values elsewhere properly
 189   3               Setup.wValue.i = Setup.wValue.c[MSB] + 256*Setup.wValue.c[LSB];
 190   3               Setup.wIndex.i = Setup.wIndex.c[MSB] + 256*Setup.wIndex.c[LSB];
 191   3               Setup.wLength.i = Setup.wLength.c[MSB] + 256*Setup.wLength.c[LSB];
 192   3      
 193   3      
 194   3               switch(Setup.bRequest)        // Call correct subroutine to handle each kind of
 195   3               {                             // standard request
 196   4                  case GET_STATUS:
 197   4                     Get_Status();
 198   4                     break;
 199   4                  case CLEAR_FEATURE:
 200   4                     Clear_Feature();
 201   4                     break;
 202   4                  case SET_FEATURE:
 203   4                     Set_Feature();
 204   4                     break;
 205   4                  case SET_ADDRESS:
 206   4                     Set_Address();
 207   4                     break;
 208   4                  case GET_DESCRIPTOR:
 209   4                     Get_Descriptor();
 210   4                     break;
 211   4                  case GET_CONFIGURATION:
 212   4                     Get_Configuration();
 213   4                     break;
 214   4                  case SET_CONFIGURATION:
 215   4                     Set_Configuration();
 216   4                     break;
 217   4                  case GET_INTERFACE:
 218   4                     Get_Interface();
 219   4                     break;
 220   4                  case SET_INTERFACE:
 221   4                     Set_Interface();
 222   4                     break;
 223   4                  default:
 224   4                     Force_Stall();          // Send stall to host if invalid request
 225   4                     break;
 226   4               }
 227   3            }
 228   2         }
 229   1      
 230   1         if (Ep_Status[0] == EP_TX)          // See if the endpoint has data to transmit to host
 231   1         {
 232   2            if (!(ControlReg & rbINPRDY))    // Make sure you don't overwrite last packet
 233   2            {
 234   3                                             // Endpoint 0 transmit mode
 235   3               
 236   3               POLL_READ_BYTE(E0CSR, ControlReg);
 237   3                                             // Read control register
 238   3      
 239   3               if ((!(ControlReg & rbSUEND)) || (!(ControlReg & rbOPRDY)))
 240   3                                             // Check to see if Setup End or Out Packet received, if so
 241   3                                             // do not put any new data on FIFO
C51 COMPILER V9.01   F34X_USB_ISR                                                          05/12/2015 22:23:48 PAGE 5   

 242   3               {
 243   4                  TempReg = rbINPRDY;        // Add In Packet ready flag to E0CSR bitmask
 244   4      
 245   4                                             // Break Data into multiple packets if larger than Max Packet
 246   4                  if (DataSize >= EP0_PACKET_SIZE)
 247   4                  {
 248   5                     Fifo_Write(FIFO_EP0, EP0_PACKET_SIZE, (BYTE *)DataPtr);// Put Data on Fifo
 249   5                     DataPtr  += EP0_PACKET_SIZE;                           // Advance data pointer
 250   5                     DataSize -= EP0_PACKET_SIZE;                           // Decrement data size
 251   5                     DataSent += EP0_PACKET_SIZE;                           // Increment data sent counter
 252   5                  }
 253   4                  else                       // If data is less than Max Packet size or zero
 254   4                  {
 255   5                     Fifo_Write(FIFO_EP0, DataSize, (BYTE *)DataPtr);       // Put Data on Fifo
 256   5                     TempReg |= rbDATAEND;                                  // Add Data End bit to bitmask
 257   5                     Ep_Status[0] = EP_IDLE;                                // Return EP 0 to idle state
 258   5                  }
 259   4                  if (DataSent == Setup.wLength.i)
 260   4                                              // This case exists when the host requests an even multiple of
 261   4                                              // your endpoint zero max packet size, and you need to exit
 262   4                                              // transmit mode without sending a zero length packet
 263   4                  {
 264   5                     TempReg |= rbDATAEND;    // Add Data End bit to mask
 265   5                     Ep_Status[0] = EP_IDLE;  // and return Endpoint 0 to an idle state
 266   5                  }
 267   4                  POLL_WRITE_BYTE(E0CSR, TempReg);                          // Write mask to E0CSR
 268   4               }
 269   3            }
 270   2         }
 271   1      }
 272          
 273          //-----------------------------------------------------------------------------
 274          // Handle_In1
 275          //-----------------------------------------------------------------------------
 276          //
 277          // Return Value : None
 278          // Parameters   : None
 279          //
 280          // This routine loads the current value from In_Packet on the Endpoint 1 fifo,
 281          // after  an interrupt is received from the last packet being transmitted
 282          //
 283          //-----------------------------------------------------------------------------
 284          
 285          void Handle_In1()
 286          {
 287   1         BYTE ControlReg;
 288   1      
 289   1         POLL_WRITE_BYTE(INDEX, 1);           // Set index to endpoint 1 registers
 290   1         POLL_READ_BYTE(EINCSR1, ControlReg); // Read contol register for EP 1
 291   1      
 292   1         if (Ep_Status[1] == EP_HALT)         // If endpoint is currently halted, 
 293   1                                              // send a stall
 294   1         {
 295   2            POLL_WRITE_BYTE(EINCSR1, rbInSDSTL);
 296   2         }
 297   1      
 298   1         else                                 // Otherwise send last updated 
 299   1                                              // data to host
 300   1         {
 301   2            if (ControlReg & rbInSTSTL)       // Clear sent stall if last packet
 302   2                                                  // returned a stall
 303   2            {
C51 COMPILER V9.01   F34X_USB_ISR                                                          05/12/2015 22:23:48 PAGE 6   

 304   3               POLL_WRITE_BYTE(EINCSR1, rbInCLRDT);
 305   3            }
 306   2      
 307   2            if (ControlReg & rbInUNDRUN)      // Clear underrun bit if it was set
 308   2            {
 309   3               POLL_WRITE_BYTE(EINCSR1, 0x00);
 310   3            }
 311   2      
 312   2                                              // Put new data on Fifo
 313   2            Fifo_Write(FIFO_EP1, EP1_PACKET_SIZE, (BYTE *)IN_PACKET);
 314   2            POLL_WRITE_BYTE(EINCSR1, rbInINPRDY);
 315   2                                              // Set In Packet ready bit, indicating 
 316   2         }                                    // fresh data on Fifo 1
 317   1      }
 318          
 319          //-----------------------------------------------------------------------------
 320          // Handle_Out2
 321          //-----------------------------------------------------------------------------
 322          //
 323          // Return Value : None
 324          // Parameters   : None
 325          //
 326          // Take the received packet from the host off the fifo and put it into
 327          // the Out_Packet array
 328          //
 329          //-----------------------------------------------------------------------------
 330          
 331          void Handle_Out2()
 332          {
 333   1         BYTE Count = 0;
 334   1         BYTE ControlReg;
 335   1      
 336   1         POLL_WRITE_BYTE(INDEX, 2);          // Set index to endpoint 2 registers
 337   1         POLL_READ_BYTE(EOUTCSR1, ControlReg);
 338   1      
 339   1         if (Ep_Status[2] == EP_HALT)        // If endpoint is halted, send a stall
 340   1         {
 341   2            POLL_WRITE_BYTE(EOUTCSR1, rbOutSDSTL);
 342   2         }
 343   1      
 344   1         else                                // Otherwise read packet from host
 345   1         {
 346   2            if (ControlReg & rbOutSTSTL)     // Clear sent stall bit if last packet 
 347   2                                             // was a stall
 348   2            {
 349   3               POLL_WRITE_BYTE(EOUTCSR1, rbOutCLRDT);
 350   3            }
 351   2      
 352   2            POLL_READ_BYTE(EOUTCNTL, Count);
 353   2            if (Count != EP2_PACKET_SIZE)    // If host did not send correct packet 
 354   2                                                 // size, flush buffer
 355   2            {
 356   3               POLL_WRITE_BYTE(EOUTCNTL, rbOutFLUSH);
 357   3            }
 358   2            else                             // Otherwise get the data packet
 359   2            {
 360   3               Fifo_Read(FIFO_EP2, EP2_PACKET_SIZE, (BYTE*)OUT_PACKET);
 361   3            }
 362   2            POLL_WRITE_BYTE(EOUTCSR1, 0);    // Clear Out Packet ready bit
 363   2         }
 364   1      }
 365          
C51 COMPILER V9.01   F34X_USB_ISR                                                          05/12/2015 22:23:48 PAGE 7   

 366          //-----------------------------------------------------------------------------
 367          // Usb_Suspend
 368          //-----------------------------------------------------------------------------
 369          //
 370          // Return Value : None
 371          // Parameters   : None
 372          //
 373          // Enter suspend mode after suspend signalling is present on the bus
 374          //
 375          //-----------------------------------------------------------------------------
 376          
 377          void Usb_Suspend(void)
 378          {          
 379   1         // Put the device in a low power configuration
 380   1                                     
 381   1         P0MDIN  = 0x00;                     // Port 0 configured as analog input
 382   1         P1MDIN  = 0x00;                     // Port 1 configured as analog input
 383   1         P2MDIN  = 0x00;                     // Port 2 configured as analog input
 384   1         P3MDIN  = 0x00;                     // Port 3 configured as analog input
 385   1      
 386   1         ADC0CN &= ~0x80;                    // Disable ADC0
 387   1         REF0CN  = 0x00;                     // Disable voltage reference
 388   1      
 389   1         OSCICN |= 0x20;                     // Put oscillator 
 390   1      
 391   1         // When the device receives a non-idle USB event, it will resume execution
 392   1         // on the instruction that follows OSCICN |= 0x20.  
 393   1      
 394   1         // Re-enable everything that was disabled when going into Suspend
 395   1      
 396   1         P0MDIN  = 0xFF;                     // Port 0 configured as digital pins
 397   1         P1MDIN  = 0x7F;                     // Port 1 pin 7 set as digital pin
 398   1         P2MDIN  = 0xFF;                     // Port 2 configured as digital pins
 399   1         P3MDIN  = 0xFF;                     // Port 3 configured as digital pins
 400   1      
 401   1         REF0CN  = 0x0E;                     // Enable voltage reference VREF
 402   1         ADC0CN |= 0x80;                     // Re-enable ADC0
 403   1      }
 404          
 405          //-----------------------------------------------------------------------------
 406          // Usb_Resume
 407          //-----------------------------------------------------------------------------
 408          //
 409          // Return Value : None
 410          // Parameters   : None
 411          //
 412          // Resume normal USB operation
 413          //
 414          //-----------------------------------------------------------------------------
 415          
 416          void Usb_Resume(void)
 417          {
 418   1         volatile int k;
 419   1      
 420   1         k++;
 421   1      
 422   1         // Add code for resume
 423   1      }
 424          
 425          //-----------------------------------------------------------------------------
 426          // Fifo_Read
 427          //-----------------------------------------------------------------------------
C51 COMPILER V9.01   F34X_USB_ISR                                                          05/12/2015 22:23:48 PAGE 8   

 428          //
 429          // Return Value : None
 430          // Parameters   :
 431          //                1) BYTE addr : target address
 432          //                2) unsigned int uNumBytes : number of bytes to unload
 433          //                3) BYTE * pData : read data destination
 434          //
 435          // Read from the selected endpoint FIFO
 436          //
 437          //-----------------------------------------------------------------------------
 438          
 439          void Fifo_Read(BYTE addr, unsigned int uNumBytes, BYTE * pData)
 440          {
 441   1         int i;
 442   1      
 443   1         if (uNumBytes)                         // Check if >0 bytes requested,
 444   1         {
 445   2            USB0ADR = (addr);                   // Set address
 446   2            USB0ADR |= 0xC0;                    // Set auto-read and initiate
 447   2                                                // first read
 448   2      
 449   2            // Unload <NumBytes> from the selected FIFO
 450   2            for(i=0;i<uNumBytes-1;i++)
 451   2            {
 452   3               while(USB0ADR & 0x80);           // Wait for BUSY->'0' (data ready)
 453   3               pData[i] = USB0DAT;              // Copy data byte
 454   3            }
 455   2      
 456   2            USB0ADR = 0;                           // Clear auto-read
 457   2      
 458   2            while(USB0ADR & 0x80);               // Wait for BUSY->'0' (data ready)
 459   2            pData[i] = USB0DAT;                  // Copy data byte
 460   2         }
 461   1      }
 462          
 463          //-----------------------------------------------------------------------------
 464          // Fifo_Write
 465          //-----------------------------------------------------------------------------
 466          //
 467          // Return Value : None
 468          // Parameters   :
 469          //                1) BYTE addr : target address
 470          //                2) unsigned int uNumBytes : number of bytes to unload
 471          //                3) BYTE * pData : location of source data
 472          //
 473          // Write to the selected endpoint FIFO
 474          //
 475          //-----------------------------------------------------------------------------
 476          
 477          void Fifo_Write(BYTE addr, unsigned int uNumBytes, BYTE * pData)
 478          {
 479   1         int i;
 480   1      
 481   1         // If >0 bytes requested,
 482   1         if (uNumBytes)
 483   1         {
 484   2            while(USB0ADR & 0x80);              // Wait for BUSY->'0'
 485   2                                                // (register available)
 486   2            USB0ADR = (addr);                   // Set address (mask out bits7-6)
 487   2      
 488   2            // Write <NumBytes> to the selected FIFO
 489   2            for(i=0;i<uNumBytes;i++)
C51 COMPILER V9.01   F34X_USB_ISR                                                          05/12/2015 22:23:48 PAGE 9   

 490   2            {
 491   3               USB0DAT = pData[i];
 492   3               while(USB0ADR & 0x80);           // Wait for BUSY->'0' (data ready)
 493   3            }
 494   2         }
 495   1      }
 496          
 497          //-----------------------------------------------------------------------------
 498          // Force_Stall
 499          //-----------------------------------------------------------------------------
 500          //
 501          // Return Value : None
 502          // Parameters   : None
 503          //
 504          // Force a procedural stall to be sent to the host
 505          //
 506          //-----------------------------------------------------------------------------
 507          
 508          void Force_Stall(void)
 509          {
 510   1         POLL_WRITE_BYTE(INDEX, 0);
 511   1         POLL_WRITE_BYTE(E0CSR, rbSDSTL);       // Set the send stall bit
 512   1         Ep_Status[0] = EP_STALL;               // Put the endpoint in stall status
 513   1      }
 514          
 515          //-----------------------------------------------------------------------------
 516          // End Of File
 517          //-----------------------------------------------------------------------------


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1031    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     19      17
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
